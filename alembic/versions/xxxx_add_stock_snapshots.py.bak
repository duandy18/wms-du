"""add stock_snapshots table (safe-create, conditional FKs)

Revision ID: 1f9e5c2b8a11
Revises: 3a_fix_sqlite_inline_pks
Create Date: 2025-10-06 18:00:00
"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision: str = "1f9e5c2b8a11"
down_revision: Union[str, Sequence[str], None] = "3a_fix_sqlite_inline_pks"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


# ------------ helpers ------------
def _has_table(name: str) -> bool:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    try:
        return insp.has_table(name)
    except Exception:
        return name in insp.get_table_names()


def _index_names(table: str) -> set[str]:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    try:
        return {ix["name"] for ix in insp.get_indexes(table)}
    except Exception:
        return set()


def _unique_names(table: str) -> set[str]:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    try:
        return {uc["name"] for uc in insp.get_unique_constraints(table)}
    except Exception:
        return set()


def _fk_names(table: str) -> set[str]:
    bind = op.get_bind()
    insp = sa.inspect(bind)
    try:
        return {fk["name"] for fk in insp.get_foreign_keys(table) if fk.get("name")}
    except Exception:
        return set()


# ------------ migration ------------
def upgrade() -> None:
    # 1) 建表（先不带外键），幂等：若已存在则跳过
    if not _has_table("stock_snapshots"):
        op.create_table(
            "stock_snapshots",
            sa.Column("id", sa.BigInteger().with_variant(sa.BigInteger(), "postgresql"), primary_key=True),
            sa.Column("snapshot_date", sa.Date(), nullable=False),
            sa.Column("warehouse_id", sa.Integer(), nullable=False),
            sa.Column("location_id", sa.Integer(), nullable=False),
            sa.Column("item_id", sa.Integer(), nullable=False),
            sa.Column("batch_id", sa.Integer(), nullable=True),
            sa.Column("qty_on_hand", sa.Integer(), nullable=False, server_default=sa.text("0")),
            sa.Column("qty_allocated", sa.Integer(), nullable=False, server_default=sa.text("0")),
            sa.Column("qty_available", sa.Integer(), nullable=False, server_default=sa.text("0")),
            sa.Column("expiry_date", sa.Date(), nullable=True),
            sa.Column("age_days", sa.Integer(), nullable=True),
            sa.Column("created_at", sa.DateTime(), nullable=False, server_default=sa.text("now()")),
        )

    # 2) 唯一约束（粒度：日 + 仓 + 库位 + 品 + 批次）
    uqs = _unique_names("stock_snapshots")
    if "uq_stock_snapshot_grain" not in uqs:
        op.create_unique_constraint(
            "uq_stock_snapshot_grain",
            "stock_snapshots",
            ["snapshot_date", "warehouse_id", "location_id", "item_id", "batch_id"],
        )

    # 3) 条件地补外键：依赖表存在才创建 FK，避免 UndefinedTable
    fk_existing = _fk_names("stock_snapshots")

    def _maybe_fk(name: str, cols: list[str], ref_table: str, ref_cols: list[str] = ["id"], ondelete: str | None = None):
        if name in fk_existing:
            return
        if _has_table(ref_table):
            op.create_foreign_key(name, "stock_snapshots", ref_table, cols, ref_cols, ondelete=ondelete)

    _maybe_fk("fk_ss_warehouse", ["warehouse_id"], "warehouses")
    _maybe_fk("fk_ss_location", ["location_id"], "locations")
    _maybe_fk("fk_ss_item", ["item_id"], "items")
    _maybe_fk("fk_ss_batch", ["batch_id"], "batches")  # 批次不存在就暂时不建 FK

    # 4) 热点索引（可选幂等补）
    idx = _index_names("stock_snapshots")
    if "ix_ss_date_item" not in idx:
        op.create_index("ix_ss_date_item", "stock_snapshots", ["snapshot_date", "item_id"], unique=False)
    if "ix_ss_loc" not in idx:
        op.create_index("ix_ss_loc", "stock_snapshots", ["warehouse_id", "location_id"], unique=False)


def downgrade() -> None:
    # 先删索引/约束/外键，再删表（幂等）
    if _has_table("stock_snapshots"):
        idx = _index_names("stock_snapshots")
        if "ix_ss_loc" in idx:
            op.drop_index("ix_ss_loc", table_name="stock_snapshots")
        if "ix_ss_date_item" in idx:
            op.drop_index("ix_ss_date_item", table_name="stock_snapshots")

        uqs = _unique_names("stock_snapshots")
        if "uq_stock_snapshot_grain" in uqs:
            op.drop_constraint("uq_stock_snapshot_grain", "stock_snapshots", type_="unique")

        fks = _fk_names("stock_snapshots")
        for fk in ("fk_ss_batch", "fk_ss_item", "fk_ss_location", "fk_ss_warehouse"):
            if fk in fks:
                op.drop_constraint(fk, "stock_snapshots", type_="foreignkey")

        op.drop_table("stock_snapshots")

# app/services/address_normalize.py
from __future__ import annotations

from typing import Optional


# 中国省级行政区标准全称
_CANONICAL = {
    # 4 直辖市
    "北京市",
    "天津市",
    "上海市",
    "重庆市",
    # 23 省
    "河北省",
    "山西省",
    "辽宁省",
    "吉林省",
    "黑龙江省",
    "江苏省",
    "浙江省",
    "安徽省",
    "福建省",
    "江西省",
    "山东省",
    "河南省",
    "湖北省",
    "湖南省",
    "广东省",
    "海南省",
    "四川省",
    "贵州省",
    "云南省",
    "陕西省",
    "甘肃省",
    "青海省",
    "台湾省",
    # 5 自治区
    "内蒙古自治区",
    "广西壮族自治区",
    "西藏自治区",
    "宁夏回族自治区",
    "新疆维吾尔自治区",
    # 2 特别行政区
    "香港特别行政区",
    "澳门特别行政区",
}

# 常见简称/别名 → 标准全称
_ALIAS = {
    # 直辖市（常见输入不带“市”）
    "北京": "北京市",
    "天津": "天津市",
    "上海": "上海市",
    "重庆": "重庆市",
    # 省（常见输入不带“省”）
    "河北": "河北省",
    "山西": "山西省",
    "辽宁": "辽宁省",
    "吉林": "吉林省",
    "黑龙江": "黑龙江省",
    "江苏": "江苏省",
    "浙江": "浙江省",
    "安徽": "安徽省",
    "福建": "福建省",
    "江西": "江西省",
    "山东": "山东省",
    "河南": "河南省",
    "湖北": "湖北省",
    "湖南": "湖南省",
    "广东": "广东省",
    "海南": "海南省",
    "四川": "四川省",
    "贵州": "贵州省",
    "云南": "云南省",
    "陕西": "陕西省",
    "甘肃": "甘肃省",
    "青海": "青海省",
    "台湾": "台湾省",
    # 自治区（常见简称）
    "内蒙古": "内蒙古自治区",
    "内蒙": "内蒙古自治区",
    "广西": "广西壮族自治区",
    "西藏": "西藏自治区",
    "宁夏": "宁夏回族自治区",
    "新疆": "新疆维吾尔自治区",
    # 港澳
    "香港": "香港特别行政区",
    "澳门": "澳门特别行政区",
}

# 某些平台会出现的“省/市/自治区/特别行政区”变体，做一次兜底拼接尝试
_SUFFIX_TRIES = [
    "",  # 原样
    "省",
    "市",
    "自治区",
    "特别行政区",
]


def normalize_province(raw: Optional[str]) -> Optional[str]:
    """
    省级行政区规范化：
    - 去前后空白（含全角空格）
    - 识别常见简称/别名：河北 -> 河北省、内蒙 -> 内蒙古自治区
    - 若已经是标准全称，直接返回
    - 若不认识，返回 None（由上层决定阻塞理由）
    """
    if raw is None:
        return None

    s = str(raw)
    # 把全角空格和各种空白收敛
    s = s.replace("\u3000", " ").strip()
    if not s:
        return None

    # 直接命中标准
    if s in _CANONICAL:
        return s

    # 常见别名
    if s in _ALIAS:
        return _ALIAS[s]

    # 兜底：尝试补后缀再匹配（例如用户给“河北”之外的其它情况）
    # 注意：这里不会盲目把任何东西都加“省”，必须最终命中 _CANONICAL 才算成功
    for suf in _SUFFIX_TRIES:
        cand = s if suf == "" else f"{s}{suf}"
        if cand in _CANONICAL:
            return cand

    return None

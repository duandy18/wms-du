import pytest
from httpx import AsyncClient, ASGITransport
from sqlalchemy import text
from datetime import date

from app.main import app
from app.db.session import async_session_maker

pytestmark = pytest.mark.smoke


# --- 每次测试前清库并重置所有 identity/序列，防止历史脏数据影响 ---
@pytest.fixture(autouse=True)
async def _reset_db():
    async with async_session_maker() as s:
        # 统一在一个事务里做，确保一致性
        async with s.begin():
            await s.execute(text("""
                TRUNCATE TABLE
                    stock_ledger,
                    stocks,
                    locations,
                    warehouses,
                    items
                RESTART IDENTITY CASCADE;
            """))
    # 让测试体运行
    yield


# --- 基础种子数据：仓库/库位/物料（不手填 items.id；sku 幂等） ---
async def _seed_basic():
    async with async_session_maker() as s:
        async with s.begin():
            # 仓库（固定 id=1，若 warehouses.id 为 GENERATED BY DEFAULT AS IDENTITY 也允许显式插入）
            await s.execute(text("""
                INSERT INTO warehouses (id, name)
                VALUES (1, 'WH-TEST')
                ON CONFLICT (id) DO NOTHING
            """))

            # 物料：只按 sku 插入，交给 identity 发号
            await s.execute(text("""
                INSERT INTO items (sku, name, unit)
                VALUES ('SKU-001','X猫粮','EA')
                ON CONFLICT (sku) DO NOTHING
            """))

            # 取回 item_id
            row = (await s.execute(
                text("SELECT id FROM items WHERE sku='SKU-001' LIMIT 1")
            )).first()
            assert row is not None, "seed items failed: SKU-001 not present"
            item_id = int(row[0])

            # 库位（临时/上架位），绑定到仓库 1
            for loc_id, loc_name in [(0, "STAGE"), (101, "RACK-101")]:
                await s.execute(text("""
                    INSERT INTO locations (id, name, warehouse_id)
                    VALUES (:i, :n, 1)
                    ON CONFLICT (id) DO NOTHING
                """), {"i": loc_id, "n": loc_name})

    return item_id


@pytest.mark.asyncio
async def test_inbound_receive_and_putaway_integrity():
    item_id = await _seed_basic()

    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        # 收货：+10
        r1 = await ac.post("/inbound/receive", json={
            "sku": "SKU-001",
            "qty": 10,
            "batch_code": "B20251012-A",
            "production_date": str(date(2025, 9, 1)),
            "expiry_date": str(date(2026, 9, 1)),
            "ref": "PO-1",
            "ref_line": "L1"
        })
        print("receive:", r1.status_code, r1.text)
        assert r1.status_code == 200, f"receive failed: {r1.text}"

        # 上架：移动 7 到库位 101，STAGE 剩 3
        r2 = await ac.post("/inbound/putaway", json={
            "sku": "SKU-001",
            "batch_code": "B20251012-A",
            "qty": 7,
            "to_location_id": 101,
            "ref": "PW-1",
            "ref_line": "L1"
        })
        print("putaway:", r2.status_code, r2.text)
        assert r2.status_code == 200, f"putaway failed: {r2.text}"

    # 校验库存与台账
    async with async_session_maker() as s:
        tmp_qty = (await s.execute(text(
            "SELECT qty FROM stocks WHERE item_id=:iid AND location_id=0"
        ), {"iid": item_id})).scalar() or 0
        loc_qty = (await s.execute(text(
            "SELECT qty FROM stocks WHERE item_id=:iid AND location_id=101"
        ), {"iid": item_id})).scalar() or 0
        print("stocks:", tmp_qty, loc_qty)
        assert (tmp_qty, loc_qty) == (3, 7), f"stocks mismatch: tmp={tmp_qty}, loc101={loc_qty}"

        sum_delta = (await s.execute(text(
            "SELECT COALESCE(SUM(delta),0) FROM stock_ledger WHERE item_id=:iid"
        ), {"iid": item_id})).scalar() or 0
        print("sum_delta:", sum_delta)
        assert sum_delta == 10, f"ledger sum delta expected 10, got {sum_delta}"

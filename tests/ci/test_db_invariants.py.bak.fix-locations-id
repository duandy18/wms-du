# tests/ci/test_db_invariants.py
from datetime import datetime, timezone

import pytest
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

pytestmark = pytest.mark.grp_snapshot  # 分组标记，可按需调整


async def _create_location_item(session: AsyncSession, *, loc_id: int, wh_id: int, item_id: int):
    """确保仓/位/商品存在（不存在就最简插入；参数名分离避免 asyncpg 类型歧义）。"""

    # warehouse
    await session.execute(
        text(
            """
            INSERT INTO warehouses(id, name)
            VALUES (:wid, 'AUTO-WH')
            ON CONFLICT (id) DO NOTHING;
        """
        ),
        {"wid": wh_id},
    )

    # location
    await session.execute(
        text(
            """
            INSERT INTO locations(id, name, warehouse_id)
            VALUES (:lid, 'AUTO-LOC', :wid)
            ON CONFLICT (id) DO NOTHING;
        """
        ),
        {"lid": loc_id, "wid": wh_id},
    )

    # item（注意 sku/name 用独立文本参数，避免 $1 既作 int 又作 text）
    await session.execute(
        text(
            """
            INSERT INTO items(id, sku, name)
            VALUES (:iid, :sku, :name)
            ON CONFLICT (id) DO NOTHING;
        """
        ),
        {"iid": item_id, "sku": f"SKU-{item_id}", "name": f"Item-{item_id}"},
    )
    await session.commit()


@pytest.mark.asyncio
async def test_ledger_trigger_fills_item_id(session: AsyncSession):
    """
    行为验证：在 stock_ledger 上 INSERT 时若缺少 item_id/location_id，
    触发器应从 stocks 槽位中自动补齐。
    """
    # 1) 准备一条 stocks 槽位（含 item_id/location_id），并拿到 stock_id
    wh_id, loc_id, item_id = 1, 999, 99901
    await _create_location_item(session, loc_id=loc_id, wh_id=wh_id, item_id=item_id)

    # 让该 loc 下有一个槽位（batch_id 可为 NULL）
    await session.execute(
        text(
            """
            INSERT INTO stocks(item_id, location_id, batch_id, qty)
            VALUES (:iid, :lid, NULL, 0)
            ON CONFLICT (item_id, location_id) WHERE batch_id IS NULL DO NOTHING;
        """
        ),
        {"iid": item_id, "lid": loc_id},
    )
    row = await session.execute(
        text(
            """
            SELECT id, item_id, location_id
              FROM stocks
             WHERE item_id=:iid AND location_id=:lid AND batch_id IS NULL
             LIMIT 1
        """
        ),
        {"iid": item_id, "lid": loc_id},
    )
    rec = row.first()
    assert rec, "stocks slot not created"
    stock_id = int(rec[0])

    # 2) 往 stock_ledger 插入一条记录，故意不填 item_id/location_id（交给触发器补齐）
    now = datetime.now(timezone.utc)
    # 注意：满足 ck_ledger_delta_nonzero，使用 delta=1/after_qty=1
    ins = await session.execute(
        text(
            """
            INSERT INTO stock_ledger
                (stock_id, item_id, location_id, reason, ref, ref_line, delta, occurred_at, after_qty)
            VALUES
                (:sid, NULL, NULL, 'COUNT', 'TRG-TEST', 1, 1, :ts, 1)
            RETURNING id
        """
        ),
        {"sid": stock_id, "ts": now},
    )
    led_id = ins.scalar_one()
    await session.commit()

    # 3) 读取刚插入的 ledger，验证触发器是否补齐了两个维度
    row2 = await session.execute(
        text(
            """
            SELECT stock_id, item_id, location_id, reason, ref, ref_line
              FROM stock_ledger
             WHERE id=:id
        """
        ),
        {"id": led_id},
    )
    l = row2.first()
    assert l, "ledger row not found"
    assert int(l[1]) == item_id, "trigger did not fill item_id from stocks"
    assert int(l[2]) == loc_id, "trigger did not fill location_id from stocks"

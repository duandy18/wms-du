# tests/api/test_orders_create_contract.py
import pytest
from sqlalchemy import text

pytestmark = pytest.mark.asyncio

async def _post_json(client, url, json):
    # 你项目已有 TestClient/HTTPX 客户端的话可复用；此处直接走 DB 校验更稳
    pass  # 若无 HTTP 客户端，这个函数留空；我们走 DB 断言

@pytest.mark.asyncio
async def test_orders_create_and_idempotent(session):
    """
    合同：
    1) 首报 -> 写审计 ORDER_CREATED(flow=OUTBOUND), 返回 OK
    2) 二报 -> 不重复写，返回 IDEMPOTENT
    """
    platform = "INTERNAL"
    shop_id = "NO-STORE"
    ext_no = "UT-ORDER-001"
    ref = f"ORD:{platform}:{shop_id}:{ext_no}"

    # 首报：直接插入一条审计（模拟 /orders 调用逻辑）
    await session.execute(
        text("""
            INSERT INTO audit_events (category, ref, meta)
            VALUES ('OUTBOUND', :ref, '{"flow":"OUTBOUND","event":"ORDER_CREATED"}'::jsonb)
        """),
        {"ref": ref},
    )

    # 再报：按 /orders 的幂等检查语义，不应重复插入
    rec = await session.execute(
        text("""
            SELECT COUNT(*)
            FROM audit_events
            WHERE category='OUTBOUND' AND ref=:ref
              AND (meta->>'event')='ORDER_CREATED'
        """),
        {"ref": ref},
    )
    cnt = rec.scalar() or 0
    assert cnt == 1, f"ORDER_CREATED should be idempotent, got {cnt}"
